<!DOCTYPE html>
<html lang="en">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IM+Fell+English:ital@0;1&display=swap" rel="stylesheet">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Example</title>
    <style>
           /* Embed your CSS here */
           #content {
               white-space: pre-wrap; /* Preserve newlines and spaces */
               position: relative;
               font-size: 24px;
               font-family: "IM Fell English", sans-serif;
           }
            .cursor {
                       position: absolute;
                       width: 1px;
                       background-color: black;
                       pointer-events: none;
                   }
    </style>
</head>
<body>
    <div id="content" style="white-space: pre-wrap;">
        Waiting for content...
    </div>
    
    <script>
        let higlightApplied = false;
        

        // Function to apply diffs to the content using DOM Range API
        function applyDiffsToFullText(textContent, diffs) {
            
            let returnText = textContent;
            diffs.forEach(diff => {
                    const { position, delete: deleteCount, insert } = diff;

                    // Apply deletions by slicing out the text
                    if (deleteCount > 0) {
                        returnText = returnText.slice(0, position) + returnText.slice(position + deleteCount);
                    }

                    // Apply insertions by slicing in the new text
                    if (insert.length > 0) {
                        returnText = returnText.slice(0, position) + insert + returnText.slice(position);
                    }
                
                });

                return returnText; // Return the modified string
        }
        
        var cursor = document.createElement('div');
            cursor.classList.add('cursor');
            document.body.appendChild(cursor);
        
        function placeCursorAtPosition(container, position) {
                // Ensure the container has at least one child node
                if (!container.firstChild) {
                    console.error('Container must have at least one child node.');
                    return;
                }

                // Create a Range object
                var range = document.createRange();

                // Function to find the text node and offset
                function getTextNodeAtPosition(node, offset) {
                    var treeWalker = document.createTreeWalker(
                        node,
                        NodeFilter.SHOW_TEXT,
                        function(node) {
                            return NodeFilter.FILTER_ACCEPT;
                        },
                        false
                    );

                    var currentNode = treeWalker.nextNode();
                    var currentOffset = 0;

                    while (currentNode) {
                        var nextOffset = currentOffset + currentNode.length;
                        if (nextOffset >= offset) {
                            return {
                                node: currentNode,
                                offset: offset - currentOffset
                            };
                        }
                        currentOffset = nextOffset;
                        currentNode = treeWalker.nextNode();
                    }

                    return null;
                }

                // Find the text node and offset at the desired position
                var textPosition = getTextNodeAtPosition(container, position);
                if (!textPosition) {
                    console.error('Position is out of bounds.');
                    return;
                }

                // Set the start and end of the range at the desired position
                range.setStart(textPosition.node, textPosition.offset);
                range.collapse(true);

                // Get the bounding rectangle of the range
                var rect = range.getBoundingClientRect();

                // Get the container's bounding rectangle
                var containerRect = container.getBoundingClientRect();

                // Calculate the cursor's position relative to the viewport
                var cursorX = rect.left + window.scrollX;
                var cursorY = rect.top + window.scrollY;

        
               
                cursor.style.left = cursorX + 'px';
                cursor.style.top = cursorY + 'px';
                cursor.style.height = rect.height + 'px';

                // Append the cursor to the body
                document.body.appendChild(cursor);

                // Clean up
                range.detach();
            }

        function highlightText(text, start, end) {
            // Get the parts of the text
            const beforeHighlight = text.slice(0, start);
            const highlightedText = text.slice(start, end);
            const afterHighlight = text.slice(end);

            // Wrap the highlighted text in a span with a background color
            const highlightedHTML = `<span style="background-color: gray;">${highlightedText}</span>`;

            // Rebuild the text content with the highlighted part
            const newHTML = beforeHighlight + highlightedHTML + afterHighlight;

            // Set the HTML content of the container
            const textContainer = document.getElementById('content');
            textContainer.innerHTML = newHTML;
            higlightApplied = true;
        }

        
    </script>

    <script>
        // Dynamically use the current IP from the URL for the WebSocket connection
        const ip = window.location.hostname;
        const wsUrl = `ws://${ip}:7789/websocket`; // Adjust the port to match your WebSocket server port
        const socket = new WebSocket(wsUrl);
        let documentText = '';
        let cursorPosition = 0;
        let startSelection = 0;
        let endSelection = 0;
        

        // Log connection open
        socket.onopen = function() {
            console.log('WebSocket connection established');
            // Send a request for content once the connection is open
            socket.send(JSON.stringify({ request: 'getContent' }));
        };

        // Handle incoming messages
        socket.onmessage = function(event) {
            const data = JSON.parse(event.data);
            console.log('Received data from server:', data);
            let contentElement;
            switch (data.mType) {
                case "reload":
                    // Render the received content
                    documentText = data.content;
                    document.getElementById('content').textContent = documentText;
                    break;
                case "diff":
                    contentElement = document.getElementById('content');
                    documentText = applyDiffsToFullText(documentText, JSON.parse(data.content));
           //         console.log('New text: ', newText);
                    contentElement.textContent = documentText;
                    break;
                case "cursorUpdate":
                    contentElement = document.getElementById('content');
                    const { startSelection, endSelection } = data.content;
                    if (startSelection !== endSelection) {
                        highlightText(documentText, startSelection, endSelection);
                    } else if (higlightApplied) {
                        contentElement.textContent = documentText;
                        higlightApplied = false;
                    }
                    placeCursorAtPosition(contentElement, data.content.cursorPosition || 0);
                    break;
            }
            

        };

        // Handle connection errors
        socket.onerror = function(error) {
            console.log('WebSocket error:', error);
        };

        // Handle connection close
        socket.onclose = function() {
            console.log('WebSocket connection closed');
        };
    </script>
</body>
</html>
